/**
  *********************************************************************************************************
  * @File               : start.s 
  * @Author             : kang.yunjie 
  * @version            : V1.0 
  * @Date               : 2018-08-02 23:00:23 
  * @Brief              : Start
  *********************************************************************************************************
  * @attention          : 
  *                       
  *********************************************************************************************************
  */

.text
.global _start

_start:

/* -关闭看门狗- */
		ldr		r0,		=0x53000000
		ldr		r1,		=0x00000000
		str		r1,		[r0]
		
/* -设置MPLL, FCLK : HCLK : PCLK = 400M : 100M : 50M- */
/* -LOCKTIME(0x4C000000) = 0xFFFFFFFF- */
		ldr		r0,		=0x4C000000
		ldr		r1,		=0xFFFFFFFF
		str		r1,		[r0]
		
/* -CLKDIVN(0x4C000014) = 0x5, tFCLK : tHCLK : tPCLK = 1 : 4 : 8- */
		ldr		r0,		=0x4C000014
		ldr		r1,		=0x00000005
		str		r1,		[r0]
		
/* -设置CPU工作于异步模式- */
		mrc		p15,		0,	r0,	c1,	c0,	0
		orr		r0,		r0,	#0xc0000000
		mcr		p15,		0,	r0,	c1,	c0,	0
		
/* -设置MPLLCON(0x4C000004) = (92<<12)|(1<<4)|(1<<0)-
 * -m = MDIV + 8 = 92 + 8 = 100-
 * -p = PDIV + 2 = 1 + 2 = 3-
 * -s = SDIV = 1-
 * -FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1) = 400M-
 */
		ldr		r0,		=0x4C000004
		ldr		r1,		=(92<<12)|(1<<4)|(1<<0)
		str		r1,		[r0]
		
/* -一旦设置PLL,就会锁定lock time直到PLL输出稳定-
 * -然后CPU工作于新的频率FCLK-
 */
		
/* -设置内存: SP栈- 
 * -分辨是nor/nand启动-
 * -写0到0地址, 再读出来-
 * -如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动-
 * -否则就是nor启动-
 */
		mov		r1,		#0
		ldr		r0,		[r1]											/* 读取0地址数据备份 */
		str		r1,		[r1]											/* 0 -> [0] */
		ldr		r2,		[r1]											/* r2 = [0] */
		cmp		r1,		r2											/* r1==r2? 如果相等表示是NAND启动 */
		ldr		sp,		=0x40000000+4096								/* 先假设是nor启动 */
		moveq	sp,		#4096										/* nand启动 */
		streq	r0,		[r1]											/* 恢复原来的值 */
		
/* -调用sdram_init函数- */
		bl		sdram_init
		
/* -重定位data段- */
		ldr		r1,		=data_load_addr								/* data段在bin文件中的地址, 加载地址 */
		ldr		r2,		=data_start									/* data段在重定位的起始地址, 运行时的地址 */
		ldr		r3,		=data_end										/* data段在重定位的结束地址 */
cpy:
		ldr		r4,		[r1]											/* 读取r1地址四个字节到r4 */
		str		r4,		[r2]											/* 写入r2地址四个字节 */
		add		r1,		r1,	#4										/* r1地址加4 */
		add		r2,		r2,	#4										/* r2地址加4 */
		cmp		r2,		r3											/* 比较r2与r3地址是否相同 */
		ble		cpy													/* r2小于等于r3跳转 */
		
/* -清除bss段- */
		ldr		r1,		=bss_start									/* bss段在重定位的起始地址, 运行时的地址 */
		ldr		r2,		=bss_end										/* bss段在重定位的结束地址 */
		mov		r3,		#0											/* 需写入bss段的值 */
clean:
		str		r3,		[r1]											/* 写入r1地址四个字节 */
		add		r1,		r1,	#4										/* r1地址加4 */
		cmp		r1,		r2											/* 比较r1与r2地址是否相同 */
		ble		clean												/* r1小于等于r2跳转 */
		
/* -调用main函数- */
		bl		main
		
halt:
/* -死循环- */
		b		halt
		
/********************************************** END OF FLEE **********************************************/
